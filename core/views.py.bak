from django.shortcuts import render
from django.db import models

# Create your views here.
from rest_framework.decorators import api_view
from rest_framework import viewsets, filters
from rest_framework.response import Response
from django.contrib.auth.hashers import check_password
from rest_framework import status
from rest_framework.decorators import action
from django.db import transaction
import random, string
from .models import Proprietario, Veiculo, Rota, Reserva, Usuario, Paragem, VeiculoRota, Cidade, Encomenda, ConfiguracaoSistema, AgendaViagem, Usuario, Bilhete, Paragem
from .serializers import ProprietarioSerializer, VeiculoSerializer, RotaSerializer, ReservaSerializer, UsuarioSerializer, ParagemSerializer, VeiculoRotaSerializer, CidadeSerializer, AgendaViagemSerializer, EncomendaSerializer, BilheteSerializer
from django.db.models import Sum
import random
from decimal import Decimal, ROUND_HALF_UP
from datetime import datetime, timedelta, date
from datetime import date
from django.utils import timezone

class ProprietarioViewSet(viewsets.ModelViewSet):
    queryset = Proprietario.objects.all()
    serializer_class = ProprietarioSerializer

class VeiculoViewSet(viewsets.ModelViewSet):
    queryset = Veiculo.objects.all()
    serializer_class = VeiculoSerializer

class RotaViewSet(viewsets.ModelViewSet):
    queryset = Rota.objects.filter(status=True)
    serializer_class = RotaSerializer
    filterset_fields = ['cidade']  # ‚Üê habilita filtro por ?cidade=ID

    def get_queryset(self):
        queryset = super().get_queryset()
        origem = self.request.query_params.get("origem")
        tipo = self.request.query_params.get("tipo_transporte")
        tipo_rota = self.request.query_params.get("tipo_rota")
        motorista_id = self.request.query_params.get("motorista")

        if origem:
            queryset = queryset.filter(cidade_id=origem)

        if tipo:
            queryset = queryset.filter(tipo_transporte=tipo)

        if tipo_rota:
            queryset = queryset.filter(tipo_rota=tipo_rota)
        
        if motorista_id:
            queryset = queryset.filter(motorista__id=motorista_id)

        return queryset

class ReservaViewSet(viewsets.ModelViewSet):
    queryset = Reserva.objects.all().prefetch_related("bilhetes")
    serializer_class = ReservaSerializer

    def get_queryset(self):
        queryset = Reserva.objects.all().prefetch_related("bilhetes")

        codigo_bilhete = self.request.query_params.get("codigo_bilhete")
        tipo_rota = self.request.query_params.get("tipo_rota")
        rota_id = self.request.query_params.get("rota")

        if tipo_rota:
            queryset = queryset.filter(rota__tipo_rota=tipo_rota)

        if rota_id:
            queryset = queryset.filter(rota__id=rota_id)

        # ‚úÖ Agora pesquisa tanto em Reserva.codigo_bilhete (urbano) 
        # quanto em Bilhete.codigo (interprovincial)
        if codigo_bilhete:
            queryset = queryset.filter(
                models.Q(codigo_bilhete=codigo_bilhete) |
                models.Q(bilhetes__codigo=codigo_bilhete)
            ).distinct()

        return queryset
    
class UsuarioViewSet(viewsets.ModelViewSet):
    queryset = Usuario.objects.all()
    serializer_class = UsuarioSerializer

# ViewSet para Paragens
class ParagemViewSet(viewsets.ModelViewSet):
    queryset = Paragem.objects.all().order_by('ordem')
    serializer_class = ParagemSerializer

    def get_queryset(self):
        queryset = Paragem.objects.all()
        rota_id = self.request.query_params.get('rota')
        if rota_id:
            queryset = queryset.filter(rota__id=rota_id).order_by('ordem')
        return queryset


# ViewSet para Associa√ß√£o Ve√≠culos-Rotas
class VeiculoRotaViewSet(viewsets.ModelViewSet):
    queryset = VeiculoRota.objects.all()
    serializer_class = VeiculoRotaSerializer
    
class CidadeViewSet(viewsets.ModelViewSet):
    queryset = Cidade.objects.all()
    serializer_class = CidadeSerializer    

@api_view(["POST"])
def conferir_bilhete(request):
    codigo = request.data.get("codigo_bilhete")
    motorista_id = request.data.get("motorista_id")

    if not codigo:
        return Response({"erro": "C√≥digo do bilhete √© obrigat√≥rio."}, status=400)

    try:
        bilhete = Bilhete.objects.select_related("reserva__rota").get(codigo=codigo)
        reserva = bilhete.reserva
        rota = reserva.rota
        tipo = rota.tipo_rota  # "urbana" ou "interprovincial"

        # ----------------------------
        # üî∂ 1) Bloqueio: Bilhete j√° usado
        # ----------------------------
        if bilhete.usado:
            return Response({"valido": False, "status": "j√° usado"}, status=200)

        # ----------------------------
        # üî∂ 2) Bloqueio: Motorista errado
        # ----------------------------
        if motorista_id and rota.motorista_id != int(motorista_id):
            return Response({"valido": False, "status": "rota_errada"}, status=200)

        # ----------------------------
        # üîµ URBANO ‚Äî regras espec√≠ficas
        # ----------------------------
        if tipo == "urbana":
            data_hoje = date.today().strftime("%Y-%m-%d")

            # Se o bilhete tiver data_viagem (apenas ap√≥s reutiliza√ß√£o)
            if bilhete.data_viagem:
                if str(bilhete.data_viagem) != data_hoje:
                    return Response({
                        "valido": False,
                        "status": "data_invalida",
                        "mensagem": f"Bilhete de {bilhete.data_viagem} n√£o √© v√°lido para hoje ({data_hoje}).",
                        "data_viagem": str(bilhete.data_viagem)
                    }, status=400)

            # Se o bilhete N√ÉO tem data_viagem (bilhete antigo), usa-se a da reserva
            else:
                if str(reserva.data_viagem) != data_hoje:
                    return Response({
                        "valido": False,
                        "status": "data_invalida",
                        "mensagem": f"Bilhete de {reserva.data_viagem} n√£o √© v√°lido para hoje ({data_hoje}).",
                        "data_viagem": str(reserva.data_viagem)
                    }, status=400)

        # ----------------------------
        # üîµ INTERPROVINCIAL ‚Äî regras espec√≠ficas
        # ----------------------------
        if tipo == "interprovincial":
            # Aqui a data usada √© sempre reserva.data_viagem
            if not reserva.data_viagem:
                return Response({
                    "valido": False,
                    "status": "sem_data",
                    "erro": "Bilhete n√£o tem data de viagem atribu√≠da."
                }, status=400)

            hoje = date.today().strftime("%Y-%m-%d")
            # Interprovincial s√≥ n√£o pode usar bilhetes PASSADOS
            if str(reserva.data_viagem) < hoje:
                return Response({
                    "valido": False,
                    "status": "data_passada",
                    "erro": f"Bilhete expirado ({reserva.data_viagem})."
                }, status=400)

        # ----------------------------
        # üî∂ 3) MARCAR COMO USADO
        # ----------------------------
        bilhete.usado = True
        bilhete.save()

        # ----------------------------
        # üî∂ 4) RESPOSTA FINAL
        # ----------------------------
        return Response({
            "valido": True,
            "rota_id": rota.id,
            "rota_nome": rota.nome,
            "tipo": tipo,
            "data_viagem": str(bilhete.data_viagem or reserva.data_viagem)
        })

    except Bilhete.DoesNotExist:
        return Response({"valido": False, "status": "inexistente"}, status=404)

       
@api_view(['GET']) 
def reservas_motorista(request, motorista_id):
    try:
        rotas_do_motorista = Rota.objects.filter(motorista__id=motorista_id, tipo_rota="urbana")  # ‚Üê adiciona filtro
        reservas = Reserva.objects.filter(rota__in=rotas_do_motorista, usado=False)
        serializer = ReservaSerializer(reservas, many=True)
        return Response(serializer.data)
    except Exception as e:
        return Response({"erro": str(e)}, status=400)    

class AgendaViagemViewSet(viewsets.ModelViewSet):
    queryset = AgendaViagem.objects.filter(ativo=True).order_by("data")
    serializer_class = AgendaViagemSerializer

    def get_queryset(self):
        rota_id = self.request.query_params.get("rota")
        qs = super().get_queryset()
        if rota_id:
            qs = qs.filter(rota_id=rota_id)
        return qs

class EncomendaViewSet(viewsets.ModelViewSet):
    queryset = Encomenda.objects.all()
    serializer_class = EncomendaSerializer  
    
class BilheteViewSet(viewsets.ModelViewSet):
    queryset = Bilhete.objects.all()
    serializer_class = BilheteSerializer    

@api_view(['POST'])
def reutilizar_bilhete_urbano(request):
    codigo = request.data.get("codigo_bilhete")
    nova_rota_id = request.data.get("nova_rota")
    nova_paragem_id = request.data.get("paragem_embarque")

    if not codigo:
        return Response({"erro": "C√≥digo do bilhete √© obrigat√≥rio."}, status=400)

    try:
        from core.models import Bilhete, Rota, Paragem
        bilhete = Bilhete.objects.get(codigo=codigo, usado=False)
        reserva = bilhete.reserva

        # ‚úÖ Bloqueia uso indevido para rotas interprovinciais
        if reserva.rota.tipo_rota != "urbana":
            return Response(
                {"erro": "Este bilhete pertence a uma rota interprovincial e deve ser reutilizado pelo painel pr√≥prio."},
                status=400
            )


        # üîπ SE A RESERVA TEM MAIS DE 1 BILHETE ‚Üí N√ÉO PERMITIR MUDAR ROTA
        if reserva.bilhetes.count() > 1 and str(reserva.rota.id) != str(nova_rota_id):
            return Response({
                "erro": "Este bilhete faz parte de uma reserva com v√°rios passageiros. N√£o √© permitido mudar a rota. Apenas a paragem pode ser alterada."
            }, status=400)

        # üîπ Caso a rota seja a mesma, permitimos apenas atualizar a paragem
        if str(reserva.rota.id) == str(nova_rota_id):
            nova_rota = reserva.rota
        else:
            nova_rota = Rota.objects.get(id=nova_rota_id)

        # üîπ Calcular comiss√£o apenas para este bilhete (valor de 1 passagem)
        valor_passagem = Decimal(nova_rota.valor_passagem or 0)
        comissao = (ConfiguracaoSistema.objects.first().comissao_reutilizacao or Decimal("0")) if ConfiguracaoSistema.objects.exists() else Decimal("0")
        valor_comissao = (valor_passagem * comissao).quantize(Decimal("0.01"))

        # üîπ Gerar novo c√≥digo neste bilhete, sem mexer nos outros
        bilhete.codigo = bilhete.gerar_codigo()
        bilhete.usado = False
        bilhete.embarcado = False
        bilhete.data_viagem = date.today()  
        bilhete.save()

        # üîπ Atualizar paragem e rota na reserva (rota s√≥ se permitido)
        reserva.rota = nova_rota
        reserva.paragem_embarque_id = nova_paragem_id
        reserva.save()   # ‚úÖ obrigat√≥rio


        paragem_nome = None
        if nova_paragem_id:
            paragem_nome = Paragem.objects.get(id=nova_paragem_id).nome_paragem

        return Response({
            "mensagem": "Bilhete reutilizado com sucesso.",
            "novo_codigo": bilhete.codigo,
            "rota_nome": nova_rota.nome,
            "nr_rota": nova_rota.nr_rota,
            "horario": str(nova_rota.horario),
            "paragem_embarque_nome": paragem_nome,
            "valor_base": str(valor_passagem),
            "comissao": str(valor_comissao),
            "valor_total": str(valor_comissao),  # urbano = paga s√≥ comiss√£o
        })

    except Bilhete.DoesNotExist:
        return Response({"erro": "Bilhete inv√°lido ou j√° usado."}, status=404)
    except Rota.DoesNotExist:
        return Response({"erro": "Nova rota n√£o encontrada."}, status=404)

@api_view(['POST'])
def reutilizar_bilhete_interprovincial(request):
    from core.models import Bilhete, Reserva, Rota, AgendaViagem, Paragem, ConfiguracaoSistema
    from decimal import Decimal
    from datetime import date
    import random

    codigo = request.data.get("codigo_bilhete")
    nova_rota_id = request.data.get("nova_rota")
    nova_data = request.data.get("nova_data")
    nova_paragem_id = request.data.get("paragem_embarque")

    if not codigo or not nova_rota_id or not nova_data:
        return Response({"erro": "C√≥digo do bilhete, nova rota e nova data s√£o obrigat√≥rios."}, status=400)

    try:
        # ‚úÖ Buscar bilhete real, n√£o a reserva
        bilhete = Bilhete.objects.select_related("reserva", "reserva__rota").get(codigo=codigo, usado=False)
        reserva_original = bilhete.reserva
        nova_rota = Rota.objects.get(id=nova_rota_id)

        # ‚úÖ Garantir que s√≥ interprovincial pode usar aqui
        if reserva_original.rota.tipo_rota != "interprovincial":
            return Response(
                {"erro": "Este bilhete pertence a uma rota urbana. Use o painel de Reutiliza√ß√£o Urbana."},
                status=400
            )

        # ‚úÖ Se tiver mais de 1 bilhete, n√£o pode trocar rota
        if reserva_original.bilhetes.count() > 1 and str(reserva_original.rota.id) != str(nova_rota_id):
            return Response(
                {"erro": "Este bilhete pertence a uma reserva com v√°rios passageiros. S√≥ √© permitido reutilizar para a mesma rota, alterando apenas a data."},
                status=400
            )

        # ‚úÖ Verificar se data √© futura
        hoje = date.today()
        if nova_data < str(hoje):
            return Response({"erro": "N√£o √© poss√≠vel reutilizar bilhetes para datas passadas."}, status=400)

        # ‚úÖ Verificar agenda
        agenda = AgendaViagem.objects.filter(rota=nova_rota, data=nova_data, ativo=True).first()
        if not agenda:
            return Response({"erro": "Data de viagem n√£o dispon√≠vel para esta rota."}, status=400)

        # ‚úÖ Verificar capacidade
        ocupados = Reserva.objects.filter(rota=nova_rota, data_viagem=nova_data).aggregate(total=Sum('quantidade'))["total"] or 0
        capacidade = nova_rota.veiculo.capacidade if nova_rota.veiculo else None
        if capacidade and ocupados + reserva_original.quantidade > capacidade:
            return Response({"erro": "N√£o h√° lugares suficientes na nova rota."}, status=400)

        # ‚úÖ Calcular comiss√£o
        comissao = Decimal("0.00")
        config = ConfiguracaoSistema.objects.first()
        if config:
            comissao = config.comissao_reutilizacao or Decimal("0.00")

        valor_original = Decimal(nova_rota.valor_passagem)
        valor_comissao = (valor_original * comissao).quantize(Decimal("0.01"))
        valor_total = valor_comissao

        # ‚úÖ Gerar novo c√≥digo apenas para este bilhete
        prefixo = nova_rota.nome[:4].upper().replace(" ", "")[:4]
        novo_codigo = f"{prefixo}-{random.randint(100000, 999999)}"
        bilhete.codigo = novo_codigo
        bilhete.usado = False
        bilhete.embarcado = False
        bilhete.save()

        # ‚úÖ Atualizar reserva (rota e data)
        reserva_original.rota = nova_rota
        reserva_original.data_viagem = nova_data
        if nova_paragem_id:
            reserva_original.paragem_embarque_id = nova_paragem_id
        reserva_original.save()

        return Response({
            "mensagem": "Bilhete reutilizado com sucesso.",
            "novo_codigo": novo_codigo,
            "comissao": str(valor_comissao),
            "valor_total": str(valor_total),
        })

    except Bilhete.DoesNotExist:
        return Response({"erro": "Bilhete inv√°lido ou j√° usado."}, status=404)
    except Rota.DoesNotExist:
        return Response({"erro": "Nova rota n√£o encontrada."}, status=404)


        
@api_view(['POST'])
def login_motorista(request):
    nome = request.data.get("nome")
    senha = request.data.get("senha")

    if not nome or not senha:
        return Response({"erro": "Nome e senha s√£o obrigat√≥rios."}, status=400)

    try:
        motorista = Usuario.objects.get(nome=nome, senha=senha, tipo="motorista")

        # Buscar rota associada ao motorista
        rota = Rota.objects.filter(motorista=motorista, status=True).first()

        return Response({
            "id": motorista.id,
            "nome": motorista.nome,
            "telefone": motorista.telefone,
            "tipo": motorista.tipo,
            "rota_id": rota.id if rota else None,
            "rota_nome": rota.nome if rota else None,
            "tipo_rota": rota.tipo_rota if rota else None,
        })

    except Usuario.DoesNotExist:
        return Response({"erro": "Usu√°rio ou senha inv√°lidos."}, status=400)

def gen_tx_ref():
    return "TX-" + ''.join(random.choices(string.ascii_uppercase + string.digits, k=10))

@api_view(["POST"])
def iniciar_pagamento(request):
    """
    Body:
    {
      "rota": rota_id,
      "paragem_embarque": paragem_id,
      "passageiros": [{"nome":"A","telefone":"2588..."}],
      "msisdn": "2588....",
      "valor": 100.00
    }
    """
    data = request.data
    passageiros = data.get("passageiros", [])
    rota_id = data.get("rota")
    paragem_id = data.get("paragem_embarque")
    msisdn = data.get("msisdn")
    valor = data.get("valor")

    if not (rota_id and msisdn and passageiros):
        return Response({"erro":"Dados incompletos"}, status=400)

    # Verifica disponibilidade (exemplo simples)
    try:
        rota = Rota.objects.get(id=rota_id)
    except Rota.DoesNotExist:
        return Response({"erro":"Rota n√£o encontrada"}, status=404)

    # Exemplo de verifica√ß√£o de lugares - adaptar √† tua l√≥gica
    with transaction.atomic():
        # calcula ocupados (soma quantidade reservas na data)
        ocupados = Reserva.objects.filter(rota=rota, data_viagem=rota.data_rota).aggregate(total=models.Sum('quantidade'))['total'] or 0
        capacidade = rota.veiculo.capacidade if rota.veiculo else 0
        qtd_pedido = len(passageiros)
        if capacidade and (ocupados + qtd_pedido) > capacidade:
            return Response({"erro":"Lugares insuficientes"}, status=400)

        # Cria reserva provis√≥ria (quantidade = qtd_pedido) - mant√©m estado pendente
        reserva = Reserva.objects.create(
            rota=rota,
            paragem_embarque_id=paragem_id,
            quantidade=quantidade,
            telefone=telefone,
            pago=False,
            valor_total=total
        )


        # cria Payment com ref √∫nico
        tx = gen_tx_ref()
        payment = Payment.objects.create(
            transaction_ref=tx,
            reserva=reserva,
            amount=valor,
            msisdn=msisdn,
            status="pending",
            meta={"passageiros": passageiros}
        )

    # Chamar SDK externo / API para disparar Push C2B
    # aqui podes usar o portal-sdk que carregaste ‚Äî exemplo abaixo:
    try:
        # importa aqui o SDK e faz a chamada (ex.: portalsdk.APIContext / APIRequest)
        from portalsdk import APIContext, APIRequest, APIMethodType
        api_context = APIContext()
        api_context.api_key = 'INSIRA_AQUI'  # usar vari√°vel de ambiente
        api_context.public_key = '-----PUBLIC KEY----'
        api_context.ssl = True
        api_context.method_type = APIMethodType.POST
        api_context.address = 'api.sandbox.vm.co.mz'
        api_context.port = 18352
        api_context.path = '/ipg/v1x/c2bPayment/singleStage/'
        api_context.add_parameter('input_TransactionReference', tx)
        api_context.add_parameter('input_CustomerMSISDN', msisdn)
        api_context.add_parameter('input_Amount', str(valor))
        api_context.add_parameter('input_ThirdPartyReference', 'REF-'+tx)
        api_context.add_parameter('input_ServiceProviderCode', '171717')

        api_context.add_header('Origin','*')

        api_request = APIRequest(api_context)
        result = api_request.execute()

        # Guardar resposta bruta para auditoria
        payment.meta.update({"provider_init_response": {
            "status_code": getattr(result,'status_code',None),
            "body": getattr(result,'body',None)
        }})
        payment.save(update_fields=["meta"])

    except Exception as e:
        # Se o envio ao provedor falhar, cancela ou marca como failed
        payment.status = "failed"
        payment.meta = (payment.meta or {})
        payment.meta["init_error"] = str(e)
        payment.save()
        # libera lugares (se necess√°rio) ou marca reserva para remo√ß√£o
        return Response({"erro":"Erro ao iniciar pagamento"}, status=500)

    # Retorna ao frontend info m√≠nima
    return Response({"transaction_ref": payment.transaction_ref, "status": payment.status})